<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="mscorlib" #>
<#@ assembly name="System.Threading.Tasks" #>
<#@ assembly name="System.Text.Encoding" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.Common.1.3.2\lib\net45\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)\packages\Microsoft.CodeAnalysis.CSharp.1.3.2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
    WriteLine("// ------------------------------------------------------------------------------------------------");
    WriteLine("// This code was generated by TeaForPoco");
    WriteLine("// Created by Software Wizard");
    WriteLine("//");
    WriteLine("// Do not make changes directly to this file - edit the template instead.");
    WriteLine("// ------------------------------------------------------------------------------------------------");
#>
<#+ // Setting Declarations - edit these in the main <name>.tt file *******************************************************************************
    public string EnumModuleName = string.Empty;
    public string EnumPath = string.Empty;
    
    public string PocoClassPath = string.Empty;
    public string PocoClassFilenameSuffix = string.Empty;
    public string PocoClassSuffix = string.Empty;
    public bool RemoveClassSuffix = false;
    public string InterfaceModuleName = string.Empty;
    public Dictionary<string, string> CustomPlurals = new Dictionary<string, string>();
    
    // Private variables / constants
    private const string INTERFACE_REGEX = @"^I[A-Z]\w*";
#>
<#+ // PocoClassReader *********************************************************************************************************************
    public IEnumerable<PocoClass> ReadPocoClasses(string path)
    {
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("Path is Empty");
        }

        var pocoClasses = new List<PocoClass>();
        var directoryInfo = new DirectoryInfo(path);
        var pocoClassFilenameSearchPattern = $"*{PocoClassFilenameSuffix}.cs";
        var pocoClassFiles = directoryInfo.EnumerateFiles(pocoClassFilenameSearchPattern, SearchOption.AllDirectories);

        foreach (var file in pocoClassFiles)
        {
            var fileContent = file.OpenText().ReadToEnd();
            var tree = CSharpSyntaxTree.ParseText(fileContent);
            var syntaxRoot = tree.GetRoot();
            var classDeclarations = syntaxRoot.DescendantNodes().OfType<ClassDeclarationSyntax>();

            var pocoClassesInFile = classDeclarations.Select(classDeclaration => new PocoClass
                {
                    Name = RemoveClassSuffix
                    ? classDeclaration.Identifier.Text.Replace(PocoClassFilenameSuffix, string.Empty)
                    : classDeclaration.Identifier.Text,
                    BaseClasses = GetBaseClasses(classDeclaration),
                    BaseInterfaces = GetBaseInterfaces(classDeclaration),
                    PocoProperties = GetPocoClassProperties(classDeclaration)
                    }).ToList();

            pocoClasses.AddRange(pocoClassesInFile);
        }

        return pocoClasses;
    }

    private IList<PocoProperty> GetPocoClassProperties(ClassDeclarationSyntax classDeclaration)
    {
        var propertyDeclarations = classDeclaration.Members
            .OfType<PropertyDeclarationSyntax>()
            .Where(x => x.ExplicitInterfaceSpecifier == null)
            .ToList();

        return propertyDeclarations.Select(propertyDeclaration => new PocoProperty
            {
                Name = propertyDeclaration.Identifier.Text,
                TypeSyntax = propertyDeclaration.Type
                }).ToList();
    }

    private IList<string> GetBaseClasses(ClassDeclarationSyntax classDeclaration)
    {
        
        if (classDeclaration.BaseList != null && classDeclaration.BaseList.Types.Any())
        {
            return classDeclaration.BaseList.Types
                .Select(x => x.Type)
                .OfType<IdentifierNameSyntax>()
                .Where(x => !Regex.IsMatch(x.Identifier.Text, INTERFACE_REGEX))
                .Select(x => x.Identifier.Text)
                .ToList();
        }

        return new List<string>();
    }
    
    private IList<string> GetBaseInterfaces(ClassDeclarationSyntax classDeclaration)
    {
        
        if (classDeclaration.BaseList != null && classDeclaration.BaseList.Types.Any())
        {
            return classDeclaration.BaseList.Types
                .Select(x => x.Type)
                .OfType<IdentifierNameSyntax>()
                .Where(x => Regex.IsMatch(x.Identifier.Text, INTERFACE_REGEX))
                .Select(x => x.Identifier.Text)
                .ToList();
        }

        return new List<string>();
    }
 #>
<#+ public class PocoClass
    {
        public string Name { get; set; }
        
        public IList<string> BaseClasses { get; set; }

        public IList<string> BaseInterfaces { get; set; }

        public IList<PocoProperty> PocoProperties { get; set; }
    }
 #>
<#+ public class PocoProperty
    {
        public string Name { get; set; }

        public TypeSyntax TypeSyntax { get; set; }
    }
 #>
<#+ // EnumReader *********************************************************************************************************************
    public static class EnumReader
    {
        public static IEnumerable<EnumItem> Read(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("Enum Path is Empty");
            }

            var enumItems = new List<EnumItem>();
            var directoryInfo = new DirectoryInfo(path);
            var enumFiles = directoryInfo.EnumerateFiles("*.cs", SearchOption.AllDirectories);

            foreach (var file in enumFiles)
            {
                var fileContent = file.OpenText().ReadToEnd();
                var tree = CSharpSyntaxTree.ParseText(fileContent);
                var syntaxRoot = tree.GetRoot();
                var enumDeclarations = syntaxRoot.DescendantNodes().OfType<EnumDeclarationSyntax>();

                var enumItem = enumDeclarations.Select(enumDeclaration => new EnumItem
                    {
                        Name = enumDeclaration.Identifier.Text,
                        EnumMemberItems = enumDeclaration.Members.Select(enumMemberDeclaration => new EnumMemberItem
                        {
                            Name = enumMemberDeclaration.Identifier.Text,
                            Value = enumMemberDeclaration.EqualsValue != null
                            ? enumMemberDeclaration.EqualsValue.Value.ToString()
                            : string.Empty
                            }).ToList()
                        }).First();
                 
                enumItems.Add(enumItem);
            }

            return enumItems;
        }
    }
 #>
<#+ public class EnumItem
    {
        public string Name { get; set; }

        public List<EnumMemberItem> EnumMemberItems { get; set; }
    }
 #>
<#+ public class EnumMemberItem
    {
        public string Name { get; set; }

        public string Value { get; set; }
    }
#>