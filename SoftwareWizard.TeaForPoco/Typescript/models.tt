<#@ include file="..\TeaForPoco.Core.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".generated.ts" #>
<#
    // Please make changes to the settings below.
    // All you have to do is save this file, and the output file(s) is/are generated.
    // or Select "Run Custom Tool" from File Context Menu
    // or Select "Transform all T4 Templates" from VS Build Menu.
    // Compiling does not regenerate the file(s)!
    // Hint: Before modifing the template install T4 Editor Plugin for VS from Devart and ForTea Resharper Plugin. Have more fun.

    // Main settings ************************************************************************************************************
    EnumModuleName = "enums";
    EnumPath = @"..\SampleEnum";

    PocoClassPath = @"..\SampleDto";
    PocoClassFilenameSuffix = "Dto";
    PocoClassSuffix = "Dto";
    RemoveClassSuffix = true;
    InterfaceModuleName = "models";
    CustomPlurals = new Dictionary<string, string>
    {
        {"UserSummary", "UserSummaries"}
    };
    
    // ##########################################################################################################################
#>
// <auto-generated>
// ReSharper disable ConvertPropertyToExpressionBody
// ReSharper disable DoNotCallOverridableMethodsInConstructor
// ReSharper disable InconsistentNaming
// ReSharper disable PartialMethodWithSinglePart
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable RedundantNameQualifier
// ReSharper disable RedundantOverridenMember
// ReSharper disable UseNameofExpression

declare module <#=        InterfaceModuleName  #>
{
<#
    var path = Host.ResolvePath(EnumPath);
    _enumNames = EnumReader.Read(path).Select(item => item.Name).ToList();

    path = Host.ResolvePath(PocoClassPath);
    var pocoClasses = ReadPocoClasses(path).ToList();
    _pocoClassNames = pocoClasses.Select(item => item.Name).ToList();

    foreach (var pocoClass in pocoClasses) { #>
    export interface <#= GetInterfaceName(pocoClass.Name) #> <#= GetInterfaceExtensions(pocoClass.BaseClasses) #> 
    {
<#        foreach (var property in pocoClass.PocoProperties)
        {
            WriteProperty(property);
        } #>
    }

<#    } #>
}
// </auto-generated>
<#+
    // --------- Static Declarations  --------------------------------------------------------------------
    List<string> _enumNames = new List<string>();
    List<string> _pocoClassNames = new List<string>();
    readonly List<string> _collectionTypeSuffixes = new List<string> {"Collection", "List", "Array", "Enumerable"};
    readonly List<string> _dictionaryTypeSuffixes = new List<string> { "Dictionary"};
    readonly Dictionary<string, string> _typescriptTypes = new Dictionary<string, string> {
            { "double", "number"},
            { "int", "number"},
            { "string", "string"},
            { "bool", "boolean"},
            { "DateTime", "Date"}
    };  
    
    // --------- Direct Output Methods  -----------------------------------------------------------------
    private void WriteProperty(PocoProperty property)
    { #>
        <#=  GetPropertyName(property.Name) #> : <#= GetPropertyType(property.TypeSyntax) #>,      
<#+ }
    
    // --------- Internal Methods -----------------------------------------------------------------------
    public string GetInterfaceExtensions(IList<string> baseClasses)
    {
        if (baseClasses == null || !baseClasses.Any())
        {
            return string.Empty;
        }

        var interfaceNames = RemoveClassSuffix
            ? baseClasses.Select(item => item.Replace(PocoClassSuffix, string.Empty))
            : baseClasses;

        interfaceNames = interfaceNames.Select(item => $"I{item}");
        var interfaceList = string.Join(", ", interfaceNames);
        
        return $"extends {interfaceList}"; 
    }

    private string GetInterfaceName(string pocoClassName)
    {
        var interfaceName = RemoveClassSuffix
            ? pocoClassName.Replace(PocoClassSuffix, string.Empty)
            : pocoClassName;

        return $"I{interfaceName}";
    }

    private string GetPropertyName(string propertyName)
    {
        if (RemoveClassSuffix)
        {
            if (propertyName.EndsWith(PocoClassSuffix))
            {
                propertyName = propertyName.Replace(PocoClassSuffix, string.Empty);
            }
            else if (propertyName.EndsWith(PocoClassSuffix + "s"))
            {
                propertyName = propertyName.Replace(PocoClassSuffix + "s", string.Empty);
                propertyName = CustomPlurals.ContainsKey(propertyName) 
                    ? CustomPlurals[propertyName] 
                    : propertyName + "s";
            }
        }

        return ToLowerCamelCase(propertyName);
    }

    private string GetPropertyType(TypeSyntax typeSyntax)
    {
        if (typeSyntax is IdentifierNameSyntax)
        {
            var propertyType = ((IdentifierNameSyntax)typeSyntax).Identifier.Text;
            return GetTypescriptType(propertyType);
        }

        if (typeSyntax is PredefinedTypeSyntax)
        {
            var propertyType = ((PredefinedTypeSyntax)typeSyntax).Keyword.Text;
            return GetTypescriptType(propertyType);
        }

        if (typeSyntax is NullableTypeSyntax)
        {
            var nullableTypeSyntax = ((NullableTypeSyntax)typeSyntax).ElementType;
            return GetPropertyType(nullableTypeSyntax);
        }

        if (typeSyntax is ArrayTypeSyntax)
        {
            var elementTypeSyntax = ((ArrayTypeSyntax) typeSyntax).ElementType;
            return $"{GetPropertyType(elementTypeSyntax)}[]";
        }

        if (typeSyntax is GenericNameSyntax)
        {
            var genericType = (GenericNameSyntax)typeSyntax;
            var identifier = ((GenericNameSyntax) typeSyntax).Identifier.Text;
            var isCollectionType = _collectionTypeSuffixes.Any(item => identifier.EndsWith(item));
            var isDictionaryType = _dictionaryTypeSuffixes.Any(item => identifier.EndsWith(item));

            var nestedTypeSyntax = genericType.TypeArgumentList.Arguments
                        .OfType<TypeSyntax>()
                        .First();               

            if (isCollectionType)
            {
                return $"{GetPropertyType(nestedTypeSyntax)}[]";
            }

            if (isDictionaryType)
            {
                var secondNestedTypeSyntax = genericType.TypeArgumentList.Arguments
                    .Skip(1)
                    .First();

                return $"{{[index: {GetPropertyType(nestedTypeSyntax)}] : {GetPropertyType(secondNestedTypeSyntax)}}}";
            }

            return $" {GetTypescriptType(genericType.Identifier.Text)} < {nestedTypeSyntax}>";
        }

        return "any";
    }
    
    private string GetTypescriptType(string propertyTypeName)
    {
        propertyTypeName  = RemoveClassSuffix
            ? propertyTypeName.Replace(PocoClassSuffix, string.Empty)
            : propertyTypeName;

        var isClassType = _pocoClassNames.Any(item => item == propertyTypeName);
        if (isClassType)
        {
            return $"I{propertyTypeName}";
        }

        if (_typescriptTypes.ContainsKey(propertyTypeName))
        {
            return _typescriptTypes[propertyTypeName];
        }

        var isEnum = _enumNames.Any(x => x == propertyTypeName);
        if (isEnum)
        {
            return $"{EnumModuleName}.{propertyTypeName}";
        }

        Warning($"Type not found : {propertyTypeName}");
        return "any";
    }

    private static string ToLowerCamelCase(string name)
    {
        return !string.IsNullOrEmpty(name) 
            ? $"{name[0].ToString().ToLowerInvariant()}{name.Substring(1)}" 
            : name;
    }
#>





